// EDR-Blast.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <Windows.h>
#include <TlHelp32.h>


// Gets the PID of specified process
int GetTargetPID(LPCWSTR procname) {

    HANDLE hProcSnap;
    int pid = 0;
    PROCESSENTRY32W pe;


    hProcSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hProcSnap == INVALID_HANDLE_VALUE) {
        printf("Failed to open handle to Toolhelp32: %p\n", hProcSnap);
        return 1;
    }
    pe.dwSize = sizeof(PROCESSENTRY32W);
    if (!Process32FirstW(hProcSnap, &pe)) {
        printf("Failed to get first process");
        CloseHandle(hProcSnap);
        return 1;
    }

    while (Process32NextW(hProcSnap, &pe)) {
        if (lstrcmpW(procname, (LPCWSTR)pe.szExeFile) == 0) {
            pid = pe.th32ProcessID;
            printf("Process: %ws || PID: %d\n", pe.szExeFile, pe.th32ProcessID);
            break;
        }
    }

    CloseHandle(hProcSnap);
    return pid;

}

// Takes the PID that you want to check for hooks
BYTE* ListTargetModules(int pid) {

    HANDLE hModSnap;
    MODULEENTRY32 me;
    LPCWSTR dll = L"KERNELBASE.dll";
    BYTE* base_addr = 0;

    // Elevate Process Privs

    hModSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid);
    if (hModSnap == INVALID_HANDLE_VALUE) {
        printf("Failed to open ToolModule handle: Error code %d\n", GetLastError());
        return NULL;
    }
    
    me.dwSize = sizeof(MODULEENTRY32);
    if (Module32FirstW(hModSnap, &me)) {
        printf("Listing loaded DLLs\n");
        do {
            printf("%ws is loaded at 0x%p\n", me.szExePath, me.modBaseAddr);
            if (lstrcmpW(dll, me.szModule) == 0) {
                base_addr = me.modBaseAddr;
            }
        } while (Module32NextW(hModSnap, &me));
    }
    CloseHandle(hModSnap);
    return base_addr;
}

// Checks for hook installed on function
VOID CheckForHook(CHAR* name, BYTE* address) {
    BYTE* opcode = address;
    if (*opcode == 0xff, 0x25) {
        printf("%s is Hooked!\n", name);
    }
}

// Loops thorugh exports of DLL
void DumpExports(BYTE* base_addr) {
    // DOS Header
    IMAGE_DOS_HEADER* MZ = (IMAGE_DOS_HEADER*)base_addr;
    // Nt Headers
    IMAGE_NT_HEADERS* PE = (IMAGE_NT_HEADERS*)(base_addr + MZ->e_lfanew);
    IMAGE_EXPORT_DIRECTORY* IED = (IMAGE_EXPORT_DIRECTORY*)(base_addr + PE->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

    DWORD* name = (DWORD*)(base_addr + IED->AddressOfNames);
    DWORD* address = (DWORD*)(base_addr + IED->AddressOfFunctions);
    

    DWORD i = 0;
    for (i; i < IED->NumberOfNames; i++)
    {
        printf("Name: %s\nVirtual Address: 0x%p\n", base_addr + name[i], base_addr + address[i]);
        if (lstrcmpA("VirtualProtect", (LPCSTR)(base_addr + name[i])) == 0) {
            // No looking at kernelbase in memory but different one so no hooks are applied
            CheckForHook((CHAR*)base_addr + name[i], base_addr + address[i]);
        }
    }

}



int main()
{
    // Will hold target PID
    int target_pid;
    BYTE* kernel_baseAddr;
    // Process to check for hooks
    LPCWSTR target_process = L"svchost.exe";
    // Returns target PID
    target_pid = GetTargetPID(target_process);

    // Will list DLLs loaded in process
    kernel_baseAddr = ListTargetModules(target_pid);

    // Dump the export table for said DLL
    DumpExports(kernel_baseAddr);

    getchar();

}

