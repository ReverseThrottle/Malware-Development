// Hooking.cpp : This file contains the 'main' function. Program execution begins and ends there.
//


#include <Windows.h>
#include <iostream>

// Our hooked MessageBox function which takes the same parameters our MessageBox
typedef int(__stdcall* tMessageBoxA) (HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);

// Declaring variable
tMessageBoxA oMessageBoxA;

// Function to be run after our hook
int __stdcall hkMessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType) {

    std::cout << "Hooked" << std::endl;
    return oMessageBoxA(hWnd, lpText, lpCaption, uType);
}


bool WriteHook(BYTE* src, BYTE* dst, const uintptr_t len) {

    if (len < 5) return false;

    DWORD curProtection;
    // Changes protection on region of memory to change our values
    VirtualProtect(src, len, PAGE_EXECUTE_READWRITE, &curProtection);
    
    // Gets the relative address after stolen bytes
    uintptr_t relativeAddress = dst - src - 5;
    
    // Unconditional jump
    *src = 0xE9;
    
    *(uintptr_t*)(src + 1) = relativeAddress;
    VirtualProtect(src, len, curProtection, &curProtection);
    return true;
}

BYTE* TrampolineHook(BYTE* src, BYTE* dst, const uintptr_t len) {
    if (len < 5) return 0;

    // Creates region where we store our stolen bytes
    BYTE* gateway = (BYTE*)VirtualAlloc(0, len, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    // Copies stolen bytes to gateway 
    memcpy_s(gateway, len, src, len);

    // Gets relative address   
    uintptr_t gatewayRelativeAddr = src - gateway - 5;

    // Unconditional jump
    *(gateway + len) = 0xE9;

    *(uintptr_t*)((uintptr_t)gateway + len + 1) = gatewayRelativeAddr;

    // Calls our function to write the hook at the beginning of MessageBOx
    WriteHook(src, dst, len);

    return gateway;
}

int main()
{
    MessageBoxA(NULL, "Hello Non-Hooked MessageBox!", "Non-Hooked", MB_OK);

    // Gets handle to user32.dll -> MessageBoxA
    HMODULE hUser32 = GetModuleHandleA("user32.dll");
    if (hUser32 == NULL)
        printf("Failed to retrieve handle to user32.dll");

    // Returns the address of MessageBoxA
    oMessageBoxA = (tMessageBoxA)GetProcAddress(hUser32, "MessageBoxA");
    
    // Calls our trampoline function which in turn calls our hook function to write our hook
    oMessageBoxA = (tMessageBoxA)TrampolineHook((BYTE*)oMessageBoxA, (BYTE*)hkMessageBoxA, 5);
    
    // Call hooked function
    hkMessageBoxA(NULL, "Hello Hooked MessageBox!", "Hooked", MB_OK);



}
