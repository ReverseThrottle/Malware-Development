// Hooking.cpp : This file contains the 'main' function. Program execution begins and ends there.
//


#include <Windows.h>
#include <iostream>
#include <vector>

typedef int (WINAPI * tMessageBoxA)(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);

tMessageBoxA oMessageBoxA = MessageBoxA;


int WINAPI hkMessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType) {

    //std::cout << "Hooked" << std::endl;

    return oMessageBoxA(hWnd, "You are hooked baby!", "Hooky", uType);
}


bool WriteHook(BYTE* src, BYTE* dst, const uintptr_t len, HANDLE hProc) {

    if (len < 5) return false;

    DWORD curProtection;
    // Changes protection to XRW
    VirtualProtect(src, len, PAGE_EXECUTE_READWRITE, &curProtection);

    // Gets the RVA taking dst (our hookFunc/gateway) - src (MessageBoxA func) - 5 (the 5 bytes that we stole)
    uintptr_t relativeAddress = dst - src - 5;

    printf("RVA: 0x%-x\n", relativeAddress);

    // E9 is JMP
    char buff[] = { 0xE9 };

    // Writes JMP instruction
    WriteProcessMemory(hProc, src, buff, 1, NULL);

    // Addr of our hookFunc/Gateway
    *(uintptr_t*)(src + 1) = relativeAddress;
    
    // Changes protections back 
    VirtualProtect(src, len, curProtection, &curProtection);

    return true;
}

BYTE* TrampolineHook(BYTE* src, BYTE* dst, const uintptr_t len, HANDLE hProc) {

    if (len < 5) return 0;

    // Allocates our gateway (which is where we will store our stolen bytes)
    BYTE* gateway = (BYTE*)VirtualAlloc(0, len, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    // Copies 5 bytes to our gateway addr
    memcpy_s(gateway, len, src, len);

    printf("src: 0x%-16x\ngateway: 0x%-x\n", src, gateway);

    // RVA MessageBoxA func addr - gatway addr - 5 (byes we stole)
    uintptr_t gatewayRelativeAddr = src - gateway - 5;

    printf("RVA: 0x%-x\n", gatewayRelativeAddr);

    // Used to determine where to write JMP instruction
    LPVOID lpAddr = gateway + 5;
    // JMP Opcode
    char buff[] = { 0xE9 };

    // Writes JMP instruction in gateway 
    WriteProcessMemory(hProc, lpAddr, buff, 1, NULL);

    // Addr of MessageBoxA but after our JMP to our hook
    *(uintptr_t*)((uintptr_t)gateway + len + 1) = gatewayRelativeAddr;

    // Calls our hook function
    WriteHook(src, dst, len, hProc);

    // Returns our gateway addr
    return gateway;
}



int main()
{


    // Gets handle to user32.dll -> MessageBoxA
    HMODULE hUser32 = GetModuleHandleA("user32.dll");
    if (hUser32 == NULL) {
        printf("Failed to retrieve handle");
    }

    // Returns the address of MessageBoxA
    HANDLE hProc = GetCurrentProcess();
    
    // Returns addr of MessageBoxA
    oMessageBoxA = (tMessageBoxA)GetProcAddress(hUser32, "MessageBoxA");
    
    // Starts the creation of our trampoline -> which then calls and creates our hook
    oMessageBoxA = (tMessageBoxA)TrampolineHook((BYTE*)oMessageBoxA, (BYTE*)hkMessageBoxA, 5, hProc);

    // Calling messagebox to test hook
    MessageBoxA(NULL, "Hello Non-Hooked MessageBox!", "Non-Hooked", MB_OK);

}
