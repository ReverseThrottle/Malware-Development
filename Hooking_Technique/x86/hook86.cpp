// Hooking.cpp : This file contains the 'main' function. Program execution begins and ends there.
//


#include <Windows.h>
#include <iostream>

// Our hooked MessageBox function which takes the same parameters our MessageBox
typedef int(__stdcall* tMessageBoxA) (HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);

// Declaring variable
tMessageBoxA oMessageBoxA;

// Function to be run after our hook
int WINAPI hkMessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType) {

    //std::cout << "Hooked" << std::endl;
    return oMessageBoxA(hWnd, "You are hooked baby!", "Hooky", uType);
}


bool WriteHook(BYTE* src, BYTE* dst, const uintptr_t len, HANDLE hProc) {

    if (len < 5) return false;

    DWORD curProtection;
    VirtualProtect(src, len, PAGE_EXECUTE_READWRITE, &curProtection);

    uintptr_t relativeAddress = dst - src - 5;

    printf("RVA: 0x%-x\n", relativeAddress);

    char buff[] = { 0xE9 };

    WriteProcessMemory(hProc, src, buff, 1, NULL);
    //*src = 0xE9;

    *(uintptr_t*)(src + 1) = relativeAddress;
    
    VirtualProtect(src, len, curProtection, &curProtection);
    return true;
}

BYTE* TrampolineHook(BYTE* src, BYTE* dst, const uintptr_t len, HANDLE hProc) {
    if (len < 5) return 0;

    BYTE* gateway = (BYTE*)VirtualAlloc(0, len, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    memcpy_s(gateway, len, src, len);

    printf("src: 0x%-16x\ngateway: 0x%-x\n", src, gateway);

    uintptr_t gatewayRelativeAddr = src - gateway - 5;

    printf("RVA: 0x%-x\n", gatewayRelativeAddr);


    LPVOID lpAddr = gateway + 5;
    char buff[] = { 0xE9 };

    WriteProcessMemory(hProc, lpAddr, buff, 1, NULL);

    *(uintptr_t*)((uintptr_t)gateway + len + 1) = gatewayRelativeAddr;

    WriteHook(src, dst, len, hProc);

    return gateway;
}


int main()
{
    MessageBoxA(NULL, "Hello Non-Hooked MessageBox!", "Non-Hooked", MB_OK);

    // Gets handle to user32.dll -> MessageBoxA
    HMODULE hUser32 = GetModuleHandleA("user32.dll");
    if (hUser32 == NULL)
        printf("Failed to retrieve handle to user32.dll");

    // Returns the address of MessageBoxA
    oMessageBoxA = (tMessageBoxA)GetProcAddress(hUser32, "MessageBoxA");
    
    // Calls our trampoline function which in turn calls our hook function to write our hook
    oMessageBoxA = (tMessageBoxA)TrampolineHook((BYTE*)oMessageBoxA, (BYTE*)hkMessageBoxA, 5);
    
    // Call hooked function
    MessageBoxA(NULL, "Hello Non-Hooked MessageBox!", "Non-Hooked", MB_OK);



}
