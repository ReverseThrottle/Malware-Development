#include "pch.h"
#include <Windows.h>
#include <stdio.h>
#include <iostream>
#include <vector>


#define PtrFromRva( base, rva ) ( ( ( PBYTE ) base ) + rva )

typedef int (WINAPI* tMessageBoxA)(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
typedef LPVOID(WINAPI* tVirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD  flAllocationType, DWORD  flProtect);

tMessageBoxA oMessageBoxA = MessageBoxA;
tVirtualAlloc oVirtualAlloc = VirtualAlloc;


int WINAPI hkMessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType) {

    //std::cout << "Hooked" << std::endl;
    return oMessageBoxA(hWnd, "You are hooked baby!", "Hooky", uType);
    //return oMessageBoxA(hWnd, lpText, lpCaption, uType);
}

LPVOID WINAPI hkVirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD  flAllocationType, DWORD  flProtect) {
    if (flProtect == PAGE_EXECUTE_READWRITE) {
        printf("Not allowed to allocate region as executable,readable, and writable!\n");
        // DWORD cuPro;
        // VirtualProtect(oVirtualAlloc, sizeof(oVirtualAlloc), PAGE_EXECUTE | PAGE_READWRITE, &cuPro);
        LPVOID ret = VirtualAlloc(lpAddress, dwSize, NULL, NULL);
        return ret;
    }
}


bool WriteHook(BYTE* src, BYTE* dst, const uintptr_t len) {

    if (len < 5) return false;

    DWORD curProtection;
    VirtualProtect(src, len, PAGE_EXECUTE_READWRITE, &curProtection);

    uintptr_t relativeAddress = dst - src - 5;

    *src = 0xE9;

    *(uintptr_t*)(src + 1) = relativeAddress;
    VirtualProtect(src, len, curProtection, &curProtection);
    return true;
}

BYTE* TrampolineHook(BYTE* src, BYTE* dst, const uintptr_t len) {
    if (len < 5) return 0;

    HANDLE hSelf = GetCurrentProcess();

    BYTE* gateway = (BYTE*)VirtualAllocEx(hSelf, 0, len, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    memcpy_s(gateway, len, src, len);

    uintptr_t gatewayRelativeAddr = src - gateway - 5;

    *(gateway + len) = 0xE9;

    *(uintptr_t*)((uintptr_t)gateway + len + 1) = gatewayRelativeAddr;

    WriteHook(src, dst, len);

    return gateway;
}


BOOL HookIAT(const char* szModuleName, const char* szFuncName, PVOID pNewFunc, PVOID* pOldFunc)
{
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)GetModuleHandle(NULL);
    PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)PtrFromRva(pDosHeader, pDosHeader->e_lfanew);

    // Make sure we have valid data
    if (pNtHeader->Signature != IMAGE_NT_SIGNATURE)
        return FALSE;

    // Grab a pointer to the import data directory
    PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)PtrFromRva(pDosHeader, pNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);

    for (UINT uIndex = 0; pImportDescriptor[uIndex].Characteristics != 0; uIndex++)
    {
        char* szDllName = (char*)PtrFromRva(pDosHeader, pImportDescriptor[uIndex].Name);
        printf("[%s]\n", szDllName);

        if (!pImportDescriptor[uIndex].FirstThunk || !pImportDescriptor[uIndex].OriginalFirstThunk)
            return FALSE;

        PIMAGE_THUNK_DATA pThunk = (PIMAGE_THUNK_DATA)PtrFromRva(pDosHeader, pImportDescriptor[uIndex].FirstThunk);
        PIMAGE_THUNK_DATA pOrigThunk = (PIMAGE_THUNK_DATA)PtrFromRva(pDosHeader, pImportDescriptor[uIndex].OriginalFirstThunk);

        for (; pOrigThunk->u1.Function != NULL; pOrigThunk++, pThunk++)
        {
            // We can't process ordinal imports just named
            if (pOrigThunk->u1.Ordinal & IMAGE_ORDINAL_FLAG)
                continue;

            PIMAGE_IMPORT_BY_NAME import = (PIMAGE_IMPORT_BY_NAME)PtrFromRva(pDosHeader, pOrigThunk->u1.AddressOfData);
            printf("\t%s\n", (char*)import->Name);

            char* ImportName = (char*)import->Name;

            std::vector<char*> winApi_list = { (char*)"VirtualAlloc", (char*)"MessageBoxA" };

            for (int i = 0; i < winApi_list.size(); i++) {

                char* api = winApi_list[i];

                if (lstrcmpA(ImportName, api) == 0) {
                    printf("\tTRUE\n");

                    HMODULE hUser32 = GetModuleHandleA(szDllName);
                    if (hUser32 == NULL) {
                        printf("Failed to retrieve handle");
                        continue;
                    }


                    if (lstrcmpA(ImportName, winApi_list[1]) == 0) {
                        oMessageBoxA = (tMessageBoxA)GetProcAddress(hUser32, ImportName);
                        oMessageBoxA = (tMessageBoxA)TrampolineHook((BYTE*)oMessageBoxA, (BYTE*)hkMessageBoxA, 5);
                        continue;
                    }

                    else {
                        oVirtualAlloc = (tVirtualAlloc)GetProcAddress(hUser32, ImportName);
                        oVirtualAlloc = (tVirtualAlloc)TrampolineHook((BYTE*)oVirtualAlloc, (BYTE*)hkVirtualAlloc, 5);
                        continue;
                    }
                }
            }

        }
    }
    return TRUE;
}


int Go(void) {



}
